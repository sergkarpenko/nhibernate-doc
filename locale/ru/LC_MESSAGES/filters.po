# 
msgid ""
msgstr ""
"Project-Id-Version: NHibernate Object Relational Mapper 4.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-12-28 22:06+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../filters.rst:5
msgid "Filtering data"
msgstr ""

#: ../../filters.rst:7
msgid ""
"NHibernate provides an innovative new approach to handling data with "
"\"visibility\" rules. A *NHibernate filter* is a global, named, "
"parameterized filter that may be enabled or disabled for a particular "
"NHibernate session."
msgstr ""

#: ../../filters.rst:12
msgid "NHibernate filters"
msgstr ""

#: ../../filters.rst:14
msgid ""
"NHibernate adds the ability to pre-define filter criteria and attach those "
"filters at both a class and a collection level. A filter criteria is the "
"ability to define a restriction clause very similiar to the existing "
"\"where\" attribute available on the class and various collection elements. "
"Except these filter conditions can be parameterized. The application can "
"then make the decision at runtime whether given filters should be enabled "
"and what their parameter values should be. Filters can be used like database"
" views, but parameterized inside the application."
msgstr ""

#: ../../filters.rst:22
msgid ""
"In order to use filters, they must first be defined and then attached to the"
" appropriate mapping elements. To define a filter, use the ``<filter-def/>``"
" element within a ``<hibernate-mapping/>`` element:"
msgstr ""

#: ../../filters.rst:32
msgid "Then, this filter can be attached to a class:"
msgstr ""

#: ../../filters.rst:41
msgid "or, to a collection:"
msgstr ""

#: ../../filters.rst:49
msgid "or, even to both (or multiples of each) at the same time."
msgstr ""

#: ../../filters.rst:51
msgid ""
"The methods on ``ISession`` are: ``EnableFilter(string filterName)``, "
"``GetEnabledFilter(string filterName)``, and ``DisableFilter(string "
"filterName)``. By default, filters are *not* enabled for a given session; "
"they must be explcitly enabled through use of the "
"``ISession.EnableFilter()`` method, which returns an instance of the "
"``IFilter`` interface. Using the simple filter defined above, this would "
"look like:"
msgstr ""

#: ../../filters.rst:62
msgid ""
"Note that methods on the ``NHibernate.IFilter`` interface do allow the "
"method-chaining common to much of NHibernate."
msgstr ""

#: ../../filters.rst:65
msgid ""
"A full example, using temporal data with an effective record date pattern:"
msgstr ""

#: ../../filters.rst:97
msgid ""
"Then, in order to ensure that you always get back currently effective "
"records, simply enable the filter on the session prior to retrieving "
"employee data:"
msgstr ""

#: ../../filters.rst:108
msgid ""
"In the HQL above, even though we only explicitly mentioned a salary "
"constraint on the results, because of the enabled filter the query will "
"return only currently active employees who have a salary greater than a "
"million dollars."
msgstr ""

#: ../../filters.rst:112
msgid ""
"Note: if you plan on using filters with outer joining (either through HQL or"
" load fetching) be careful of the direction of the condition expression.  "
"It's safest to set this up for left outer joining; in general, place the "
"parameter first followed by the column name(s) after the operator."
msgstr ""

#: ../../filters.rst:117
msgid ""
"Default all filter definitions are applied to ``<many-to-one/>`` and ``<one-"
"to-one/>`` elements. You can turn off this behaviour by using ``use-many-to-"
"one`` attribute on ``<filter-def/>`` element."
msgstr ""
